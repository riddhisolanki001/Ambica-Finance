[
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Tax Withholding Category",
  "enabled": 1,
  "modified": "2024-01-02 10:47:48.806834",
  "module": "Ambica Finance",
  "name": "Tax Withholding Category Name",
  "script": "frappe.ui.form.on('Tax Withholding Category', {\n    refresh: function(frm) {\n        // Your script logic here\n    },\n    onload: function(frm) {\n        // Check if the document is in Draft state (new form)\n        if (frm.doc.docstatus === 0) {\n            // Set a default value for the __newname field during onload for new forms\n            frm.set_value('__newname', frm.doc.custom_type + '-' + frm.doc.custom_sub_category);\n        }\n    },\n    custom_section: function(frm) {\n        if (frm.doc.category_name) {\n            // Update the __newname field when custom_section changes and category_name is not null\n            frm.set_value('__newname', frm.doc.custom_type + '-' + frm.doc.custom_section + '-' + frm.doc.category_name + '-' + frm.doc.custom_sub_category);\n        } else {\n            // Handle the case when category_name is null\n            // You can run another query or set a different value as needed\n            frm.set_value('__newname', frm.doc.custom_type + '-' + frm.doc.custom_section + '-' + frm.doc.custom_sub_category);\n        }\n        \n    },\n    custom_sub_category: function(frm) {\n        // Set a default value for the __newname field by concatenating custom_type and custom_section\n        frm.set_value('__newname', frm.doc.custom_type + '-' + frm.doc.custom_section + '-' + frm.doc.category_name + '-' + frm.doc.custom_sub_category);\n    },\n    custom_type: function(frm) {\n        // Set a default value for the __newname field by concatenating custom_type and custom_section\n        frm.set_value('__newname', frm.doc.custom_type + '-' + frm.doc.custom_section + '-' + frm.doc.category_name + '-' + frm.doc.custom_sub_category);\n    }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Memorandum Invoice",
  "enabled": 1,
  "modified": "2023-12-28 15:04:52.331089",
  "module": "Ambica Finance",
  "name": "Get full address from address name",
  "script": "frappe.ui.form.on(\"Memorandum Invoice\", \"company_address_name\", function(frm, cdt, cdn) {\n    if(frm.doc.company_address_name){\n      return frm.call({\n      method: \"frappe.contacts.doctype.address.address.get_address_display\",\n      args: {\n         \"address_dict\": frm.doc.company_address_name\n      },\n      callback: function(r) {\n        if(r.message)\n            frm.set_value(\"company_address\", r.message);\n        \n      }\n     });\n    }\n    else{\n        frm.set_value(\"company_address\", \"\");\n    }\n});",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Payment Entry",
  "enabled": 0,
  "modified": "2024-01-04 10:57:37.611421",
  "module": "Ambica Finance",
  "name": "Set Cheque/Reference No",
  "script": "var isChequeBookOver = false;\n\nfrappe.ui.form.on('Payment Entry', {\n    onload: function(frm) {\n        setReferenceNoBasedOnAccountTypes(frm);\n    },\n    paid_from: function(frm) {\n        setReferenceNoBasedOnAccountTypes(frm);\n    },\n    paid_to: function(frm) {\n        setReferenceNoBasedOnAccountTypes(frm);\n    },\n    before_save: function(frm) {\n        if (isChequeBookOver) {\n            frappe.msgprint(__('Cheque Book is over. Cannot create a new Payment Entry.'));\n            frappe.validated = false; // Prevent form save\n            return;\n        }\n\n        // Check for duplicate reference_no within the document\n        var referenceNo = frm.doc.reference_no;\n\n        if (referenceNo && frm.doc.__unsaved && frm.doc.__unsaved.reference_no === referenceNo) {\n            frappe.msgprint(__('Duplicate reference number. Please set another number.'));\n            frappe.validated = false; // Prevent form save\n            return;\n        }\n\n        // Check for duplicate reference_no in existing Payment Entry records\n        frappe.call({\n            method: 'frappe.client.get_list',\n            args: {\n                doctype: 'Payment Entry',\n                filters: { reference_no: referenceNo },\n                limit: 1\n            },\n            callback: function(response) {\n                if (response.message && response.message.length > 0) {\n                    frappe.msgprint(__('Duplicate reference number. Please set another number.'));\n                    frappe.validated = false; \n                    fetchChequeBookInfoAndSetReferenceNo(frm);\n                }\n            }\n        });\n    }\n});\n\nfunction setReferenceNoBasedOnAccountTypes(frm) {\n    var paidFromAccount = frm.doc.paid_from;\n    var paidToAccount = frm.doc.paid_to;\n\n    // Fetch the account type for paid_from\n    fetchAccountType(paidFromAccount, function(accountTypeFrom) {\n        console.log('Paid From Account Type:', accountTypeFrom);\n\n        // Fetch the account type for paid_to\n        fetchAccountType(paidToAccount, function(accountTypeTo) {\n            console.log('Paid To Account Type:', accountTypeTo);\n\n            if (accountTypeFrom === 'Bank' || accountTypeTo === 'Bank') {\n                if (frm.is_new()) {\n                    fetchChequeBookInfoAndSetReferenceNo(frm);\n                }\n            } else {\n                // Set reference_no to a different value if needed\n                frm.set_value('reference_no', '');\n            }\n        });\n    });\n}\n\nfunction fetchAccountType(account, callback) {\n    frappe.call({\n        method: 'frappe.client.get_value',\n        args: {\n            doctype: 'Account',\n            fieldname: 'account_type',\n            filters: { name: account }\n        },\n        callback: function(response) {\n            var accountType = response.message ? response.message.account_type : '';\n            callback(accountType);\n        }\n    });\n}\nfunction fetchChequeBookInfoAndSetReferenceNo(frm) {\n    frappe.call({\n        method: 'frappe.client.get_list',\n        args: {\n            doctype: 'Cheque Book',\n            fields: ['name', 'from_no', 'last_no'],\n            filters: {},\n            order_by: 'creation desc',\n            limit: 1\n        },\n        callback: function(response) {\n            if (response.message && response.message.length > 0) {\n                var chequeBooksList = response.message;\n                var fromNo = chequeBooksList[0].from_no;\n                var lastNo = chequeBooksList[0].last_no;\n\n                frappe.call({\n                    method: 'frappe.client.get_list',\n                    args: {\n                        doctype: 'Payment Entry',\n                        fields: ['reference_no'],\n                        order_by: 'reference_no desc', // Descending order to find the highest existing reference_no\n                        limit: 1\n                    },\n                    callback: function(lastResponse) {\n                        var existingReferenceNos = lastResponse.message.map(entry => parseInt(entry.reference_no));\n                        var nextReferenceNo = findNextReferenceNoInRange(existingReferenceNos, fromNo, lastNo);\n\n                     if (nextReferenceNo !== null && nextReferenceNo <= lastNo) {\n                            // There is a gap in the sequence\n                            frappe.msgprint(__('Cheque Book is over. Cannot create a new Payment Entry.'));\n                            frm.set_value('reference_no', '');\n                        } else {\n                            frm.set_value('reference_no', nextReferenceNo);\n                        }\n                    }\n                });\n            }\n        }\n    });\n}\n\nfunction findNextReferenceNoInRange(existingReferenceNos, fromNo, lastNo) {\n    // Convert existing reference numbers to integers\n    existingReferenceNos = existingReferenceNos.map(Number);\n\n    // Generate an array of numbers within the specified range\n    var range = Array.from({ length: lastNo - fromNo + 1 }, (_, index) => fromNo + index);\n\n    // Filter out existing reference numbers from the generated range\n    var availableNumbers = range.filter(number => !existingReferenceNos.includes(number));\n\n    // If there are available numbers, return the highest one; otherwise, return null\n    return availableNumbers.length > 0 ? Math.max(...availableNumbers) : null;\n}\n\n",
  "view": "Form"
 }
]